'use strict';

angular.module('core').factory('Translate', ['$q','$http',
    function ($q, $http) {
        var apiKey = 'AIzaSyDXfkSLStUD8Xu3c54fY4MimW2t5V1FUIc';
        var detectLanguageUrl = 'https://www.googleapis.com/language/translate/v2/detect?key=' + apiKey + '&callback=JSON_CALLBACK&q={{query}}';
        var translateUrl = 'https://www.googleapis.com/language/translate/v2?key=' + apiKey + '&callback=JSON_CALLBACK&target=en&q={{query}}';

        return {
            detectLanguage: function (texts) {
                var defer = $q.defer();
                texts = _.map(texts, function(thread) {
                    var bodyText = thread.body.toString();
                    return encodeURIComponent(bodyText.substring(0, 25));
                }).join('.');
                var url = detectLanguageUrl.replace(/{{query}}/, texts);
                $http.get(url)
                    .success(function (result) {
                        defer.resolve(result.data.detections[0][0].language === 'en');
                    })
                    .error(function (err) {
                        defer.reject(err);
                    });

                return defer.promise;
            },
            /**
             * translate array of contents
             * @param texts
             * @param [key] if the texts is an array of object, this should hold the key to the actual content
             * @returns {jQuery.promise|promise.promise|*}
             */
            translateText: function (texts, key) {
                var defer = $q.defer();
                texts = _.map(texts, function(row) {
                    var bodyText = ((key ? row[key] : row) || '').toString();
                    return encodeURIComponent(bodyText);
                });
                // separate texts to different calls for short URI-lengths
                var bulks = [];
                var index = 0;
                _.each(texts, function(text){
                    if(!bulks[index]) bulks[index] = [];

                    var optionalQuery = bulks[index].join('&q=') + text;
                    if(optionalQuery.length < 2000) {
                        bulks[index].push(text);
                    } else {
                        index++;
                        bulks[index] = [text];
                    }
                });
                var translatedTexts = [];
                async.eachSeries(bulks, function(bulk, done) {
                    var url = translateUrl.replace(/{{query}}/,bulk.join('&q='));
                    $http({
                        method: 'JSONP',
                        url: url
                    })
                        .success(function (translatedTextResults) {
                            if(!translatedTextResults || !translatedTextResults.data) return defer.reject(translatedTextResults);
                            translatedTextResults = _.map(translatedTextResults.data.translations, function (translatedText, index) {
                                return translatedText.translatedText;
                            });
                            translatedTexts = translatedTexts.concat(translatedTextResults);
                            done();
                        })
                        .error(function (err) {
                            done(err);
                        });
                }, function(err) {
                    if(err) return defer.reject(err);
                    defer.resolve(translatedTexts);
                });

                return defer.promise;
            }
        };
    }
]);
