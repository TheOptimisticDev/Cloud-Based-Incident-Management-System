'use strict';

angular.module('accounts').controller('oneTimePaymentCtrl', oneTimePaymentCtrl);

/** @ngInject **/
function oneTimePaymentCtrl($stateParams, SweetAlert, $filter, OneTimePayments, Accounts){
	var self = this;
	self.resetForm = resetForm;
	self.$oninit = init;
	self.$onChanges = init;
	self.submit = submit;
	self.deleteInvoice = deleteInvoice;
	self.billingTypeEnum = {
		NEXT_BILLING_CYCLE: 'NEXT_BILLING_CYCLE',
		ON_FUTURE_BILLING_CYCLE: 'ON_FUTURE_BILLING_CYCLE'
	};

	self.billingTypes = {};
	self.billingTypes[self.billingTypeEnum.NEXT_BILLING_CYCLE] = 'Add to next billing cycle';
	self.billingTypes[self.billingTypeEnum.ON_FUTURE_BILLING_CYCLE] = 'Add to future billing cycle';

	function init(){
		// setting some defaults
        Accounts.getApi2({accountId: $stateParams.accountId}).$promise
		.then(function(account){
			self.nextBillingDate = account.billing.nextBillingDate;
        })
		.then(function(){
			self.endOfDay = moment().endOf('day');
			self.nextBillingDateIsInThePast = moment(self.nextBillingDate) < self.endOfDay;
			self.chargingTimeOptions = [
				{
					label: 'Add to future billing cycle',
					val: self.billingTypeEnum.ON_FUTURE_BILLING_CYCLE
				}
			];
			if(self.nextBillingDate){
				self.chargingTimeOptions.push({
					label: 'Add to next billing cycle ' + $filter('date')(self.nextBillingDate, 'shortDate'),
					val: self.billingTypeEnum.NEXT_BILLING_CYCLE,
					disabled: self.nextBillingDateIsInThePast,
					selectedByDefault: !self.nextBillingDateIsInThePast
				});
			}
			if(self.nextBillingDateIsInThePast){
				self.chargeTime = self.chargingTimeOptions[0].val;
			}else{
				self.chargeTime = self.chargingTimeOptions[1].val;
			}
			self.invoiceItem = {};
			// Getting one time payment history
			var query = {
				accountId: $stateParams.accountId
			};

			return OneTimePayments.get(query).$promise;
		})
		.then(function(results){
			results = results.results || [];
			self.upcomingPayments = results.filter(function(invoice){
				// paidAt don't exists
				return !invoice.paidAt;
			});
			self.pastPayments = results.filter(function(invoice){
				// paidAt exists
				return !!invoice.paidAt;
			});
		})
		.catch(function(err){
			console.log(err);
		});
	}

	function resetForm(frm){
		// Cancel form
		self.showForm = false;
		self.invoiceItem = {};
		frm.$setPristine();
	}

	function submit(frm){
		self.invoiceItem.accountId = $stateParams.accountId;
		if(self.chargeTime === self.billingTypeEnum.NEXT_BILLING_CYCLE){
			self.invoiceItem.shouldBePaidAt = self.nextBillingDate;
		}
		self.invoiceItem.oneTimePaymentType = self.chargeTime;
		OneTimePayments.save(self.invoiceItem).$promise
		.then(function(){
			SweetAlert.swal('', 'Payment added successfully', 'success');
			resetForm(frm);
			// Running the init to clean form state & refetch data from DB
			init();
		})
		.catch(function(err){
			SweetAlert.swal('', 'Failed to add payment', 'error');
			console.log(err);
		});
	}

	function deleteInvoice(invoiceItem){
		SweetAlert.swal({
			title: 'Delete this upcoming payment?',
			showCancelButton: true,
			confirmButtonColor: "#F0411E",
			confirmButtonText: 'Delete!'
		}, function(isConfirm){
			if(isConfirm){
				OneTimePayments.delete({otpId: invoiceItem._id, accountId: invoiceItem.accountId}).$promise
				.then(function(){
					SweetAlert.swal(
						'Deleted!',
						'Payment has been deleted.',
						'success'
					);
					init();
				});
			}
		});
	}
}

