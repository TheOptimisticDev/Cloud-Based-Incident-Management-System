'use strict';

angular.module('conversations').controller('ConversationController', [
	'$scope',
	'Authentication',
	'$stateParams',
	'Conversations',
	'ConversationsPosts',
	'gNotify',
	'ConversationsHelpers',
	'$filter',
	'Translate',
	'dataFallback',
	'$timeout',
	'$window',
	'ConversationsModalsService',
	'Reservations',
	'ReservationsHooks',
	function($scope, Authentication, $stateParams, Conversations, ConversationsPosts, gNotify, ConversationsHelpers, $filter, Translate, dataFallback, $timeout, $window, ConversationsModalsService, Reservations, ReservationsHooks){

		var self = this;

		$scope.authentication = Authentication;

		var timers = {};

		/**
		 * create schema for new conversation, for later saving new conversation
		 * @param [newConversationParams]
		 */
		function createNewConversationSchema(newConversationParams){
			if(!newConversationParams) newConversationParams = getNewConversationParamsFromState();
			$scope.newConversationParams = {
				accountId: newConversationParams.accountId || ($scope.account ? $scope.account._id : null),
				userId: newConversationParams.userId || ($scope.user ? $scope.user._id : null),
				reservationId: newConversationParams.reservationId || ($scope.conversation ? $scope.conversation._id : null),
				contactId: newConversationParams.contactId || ($scope.contact ? $scope.contact._id : null)
			};

			// Set the new conversation params
			$scope.newConversationParams.conversationWith = $scope.newConversationParams.contactId ? 'Contact' : 'User';
			$scope.newConversationParams.availableReplyModules = Conversations.availableModules($scope.newConversationParams, function(){
				// after all new conversation params are good - the composing can be available
				$scope.newConversationParams.isReady = true;
			});
		}

		/**
		 * get conversation post params from $stateParams
		 * @returns {{accountId: string, reservationId: *, contactId: (*|contactId|conversation.newConversationParams.contactId|$scope.query.contactId|searchParams.contactId)}}
		 */
		function getNewConversationParamsFromState(){
			return {
				accountId: $stateParams.accountId,
				reservationId: $stateParams.reservationId,
				contactId: $stateParams.contactId,
				userId: $stateParams.userId
			};
		}

		function getConversation(callback){
			return Conversations.get({
				conversationId: $scope.conversationId
			}, callback || angular.noop);
		}

		function mixConversationWithLogsAndSort(){
			var log = _.map(self.log, function(log){
				log.itemType = 'log';
				return log;
			});
			$scope.conversation.thread = $scope.conversation.thread.concat(log);
			$scope.conversation.thread = _.sortBy($scope.conversation.thread, function(thread){
				return -(new Date(thread.at || thread.sentAt || thread.shouldBeSendAt || thread.createdAt));
			});
		}

		function setConversationToScope(conversation, onlyThread){
			if($scope.conversation && onlyThread){
				$scope.conversation.thread = conversation.thread;
			}else{
				$scope.conversation = conversation;
			}

			// Qa Mode, hide receptionist names
			$scope.inQaMode = ($scope.viewMode === 'QA');
			if($scope.inQaMode){
				markconversationThreadsInReview();
			}

			checkForPendingPostsStatus();
			getReservation(function(){
				if(self.reservationId){
					//get the reservation log
					Reservations.get({ reservationId: self.reservationId, fields: 'log' }, function(reservation){
						self.log = reservation.log || [];
						self.reservationId = reservation._id;
						mixConversationWithLogsAndSort();
					});

					//get hooks
					ReservationsHooks.query({
						reservationId: self.reservationId,
						fields: 'scheduledTime action',
						status: 'pending',
						scheduled: true,
						from: new Date(),
						to: moment().add(24, 'hours').toDate()
					}, function(hooks){
						$scope.hooks = hooks ? hooks.reverse() : null;
					});
				}
			});
		}

		function getReservation(cb){
			var reservationId;

			//if there's a reservation in scope take that
			if($scope.reservation && $scope.reservation._id){
				reservationId = $scope.reservation._id;
			}
			//else,
			else{
				//take the last mentioned reservation
				reservationId = _.get(_.find($scope.conversation.thread, function(post){
					return post.reservationId;
				}), 'reservationId');
			}

			if(reservationId){
				//don't load again if nothing changed
				if(self.reservationId === reservationId) return;

				self.reservationId = reservationId;

				cb();

			}else if($scope.conversation.conversationWith === 'Guest'){
				//no reservation id, our last chance is to search for a reservation of that guest
				//todo
			}

		}


		// check is there are pending posts in thread - and call for a future update.
		function checkForPendingPostsStatus(){
			var pendingPost = _.find($scope.conversation.thread, function(post){
				return (post.status === 'pending' && !post.shouldBeSendAt);
			});
			if(pendingPost){
				if($scope.tab){
					$scope.tab.required = true;
					$scope.tab.checked = false;
					$scope.checkTicketDoneStatus();
				}
				timers.pending = $timeout(function(){
					getConversation(function(conversation){
						setConversationToScope(conversation, true);
					});
				}, 10000);
			}else{
				if($scope.tab){
					$scope.tab.checked = true;
					$scope.checkTicketDoneStatus();
				}
			}
		}

		// public
		$scope.messageMethods = ConversationsHelpers.getMessageMethods();


		/**
		 * initialize the conversation controller.
		 * use the conversation from scope, with fallback to $stateParams.conversationId
		 */
		$scope.init = function(){
			$scope.maxThreadsToDisplay = 50;
			$scope.hideConversationPost = $scope.hideConversationPost || false;

			// THINGS TO DO WHEN THERE'S NO conversationId
			dataFallback($scope, 'conversation', function(id, conversation){
				$scope.conversationId = id;
				$scope.conversation = conversation;

				if(conversation) return checkConversationSyncAndSetToScope(conversation);
				if(id){
					$scope.findOne();
				}else if(!$scope.hideConversationPost){
					// in case there's no conversation at all, this view includes the create-conversation-post view by default
					// if parent scope has hideConversationPost, there will be no new-post view at all.
					createNewConversationSchema($scope.newConversationParams);
				}
			});
		};

		// To avoid overloading the conversation
		$scope.showMoreThreads = function() {
			if (!$scope.conversation || $scope.maxThreadsToDisplay >= $scope.conversation.thread.length) return;
			$scope.maxThreadsToDisplay += 50;
		};

		// Find existing conversation
		$scope.findOne = function(clearBefore){
			if(clearBefore) $scope.conversation = null;
			getConversation(checkConversationSyncAndSetToScope);
		};

		// check last synced time
		function checkConversationSyncAndSetToScope(conversation){
			// even if not updated - set conversation to scope anyway
			setConversationToScope(conversation);

			// check if not synced
			if(conversation.sync){
				if(conversation.sync.error){
					gNotify.alert('Sync error: ' + conversation.sync.error);
				}else{
					if(!$scope.syncedConversation){
						gNotify.info('Syncing conversation..');
						$scope.syncingConversation = true;
					}
					timers.sync = $timeout(function(){
						$scope.findOne();
					}, 5000);
				}
			}else{
				$scope.syncingConversation = false;
			}
		}

		/**
		 * create new conversation with current scope data, and given post
		 * @param post
		 * @param cb
		 * @param failureCb
		 */
		$scope.createConversation = function(post, cb, failureCb){
			var conversation = new Conversations($scope.newConversationParams);
			conversation.thread = [post];
			conversation.$save({}, function(){
				delete $scope.newConversationParams;
				$scope.conversation = conversation;
				$scope.conversationId = conversation._id;
				cb(conversation);
			}, failureCb);
		};

		/**
		 * send all thread to google-translate and replace with current thread.
		 */
		$scope.translateThread = function(){
			Translate.translateText($scope.conversation.thread, 'body').then(function(googleTranslateResults){
				_.each($scope.conversation.thread, function(post, index){
					post.body = googleTranslateResults[index];
				});
				$scope.hideTranslateButton = true;
			}, function(){
				gNotify.alert('Could not translate the text');
			});
		};

		$scope.isAllowedToReportMistake = $scope.authentication.isAuthorized('receptionists-reviewer');

		/**
		 * report a post as a mistake
		 * @param post
		 * @param reason
		 */
		$scope.reportMistake = function(post, reason){
			var data = {
				postId: post.postId,
				conversationId: $scope.conversation._id,
				reason: reason,
				reportedAsMistakeBy: Authentication.userId()
			};
			post.isReporting = true;
			var conversationPost = new ConversationsPosts(data);
			conversationPost.$report(function(){
				gNotify.success('Post reported as mistake');
				_.extend(post, data);
			}, function(){
				post.isReporting = false;
				gNotify.alert('Failed to report mistake');
			});
		};

		$scope.mistakesReasons = ['Mistake- unprofessional', 'Mistake- hasty', 'Mistake- misunderstood', 'Bad service', 'Bug'];

		/**
		 * set feedback to conversation post
		 * @param post
		 * @param feedbackValue {String}
		 */
		$scope.setPostFeedback = function(post, feedbackValue){
			var conversation = $scope.conversation;
			$scope.disableFeedbackButtons = true;
			var conversationPost = new ConversationsPosts({
				postId: post._id,
				conversationId: conversation._id
			});
			conversationPost.$feedback({
				value: feedbackValue
			}, function(updatedPost){
				post.feedback = updatedPost.feedback;
				//todo: Analytics.track('Feedback received', _.extend({}, conversation.toJSON(), post));
			}, function(){
				$scope.disableFeedbackButtons = false;
			});
		};

		$scope.resendPost = function(post){
			post.isResending = true;
			ConversationsPosts.resend({ conversationId: $scope.conversation._id }, post, function(newPostData){
				gNotify.success('Added to queue');
				_.extend(post, newPostData);
				$scope.findOne();
			}, function(){
				gNotify.alert('Post resend failed');
				post.isResending = false;
			});
		};

		$scope.openCustomerSupportModal = function(){
			var publicNote;
			var linkToCurrentTicket;

			//public note only if this is only the host talking
			if($scope.conversation && $scope.conversation.thread){
				if(!_.find($scope.conversation.thread, { 'isOurSide': true })){
					var tmp = document.createElement('DIV');
					tmp.innerHTML = _.map($scope.conversation.thread, 'body').join('\n');
					publicNote = tmp.textContent || tmp.innerText || '';
				}
			}

			if($scope.ticket && $scope.ticket._id){
				linkToCurrentTicket = 'https://' + $window.location.host + '/inbox/' + $scope.ticket._id;
			}else if($scope.conversation && $scope.conversationId){
				linkToCurrentTicket = 'https://' + $window.location.host + '/conversations/' + $scope.conversation._id;
			}
			var account = $scope.conversation.account;
			var userId = $scope.conversation.userId;
			var message = _.find($scope.conversation.thread, { 'module': 'email' }) || {};
			//if account is unknown
			if(!account || !account._id){
				if(!account) account = {};
				//take the first message email source
				if(message){
					var email = message.from;
					//clean it
					if(_.isString(email)){
						var cleaned = email.toLowerCase();
						cleaned = cleaned.match(/[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/);
						if(cleaned){
							account.email = cleaned[0];

							//	Also adjust the fullName
							account.fullName = (account.fullName || '').replace(account.email, '').replace('<', '').replace('>', '');
						}else if(email.indexOf('<') === -1){
							account.email = cleaned;
						}
					}
				}
			}
			var subject = message.subject;

			//Open the modal
			ConversationsModalsService.openCustomerSupportModal(account, userId, subject, publicNote, null, linkToCurrentTicket).then(function(){
				// Log customer support message sent event
				Reservations.log({ reservationId: self.reservationId }, {
					event: 'Ticket sent to customer support'
				});
			});
		};

		// kill all timers on scope destroy
		$scope.$on('$destroy', function(){
			_.each(timers, function(timer){
				$timeout.cancel(timer);
			});
		});

		/** Get dashboard ticket details, if a conversation thread's created date falls between the start and completion of the ticket handling, mark it **/
		function markconversationThreadsInReview(){
			var ticketInReview = $scope.ticket;
			var timeTicketBegan = moment(ticketInReview.assignedAt);
			var timeTicketWasCompleted = moment(ticketInReview.completedAt);

			// Make sure the ticket has been completed otherwise there is nothing to review
			if(!(ticketInReview && ticketInReview.assignedAt && ticketInReview.completedAt)) return

			var firstConvoWithinTicket, lastConvoWithinTicket;
			var safeConversationThread = $scope.conversation.thread || [];
			safeConversationThread.forEach(function(thread){

				var convoThreadTimeStamp = moment(thread.createdAt);

				// This is so that there is a marking of a ticket handling even if there was no messaging involved in the ticket handling
				if(convoThreadTimeStamp.isBefore(timeTicketBegan) && !lastConvoWithinTicket){
					lastConvoWithinTicket = thread;
					thread.noConversationWithinTicket = true;
				}

				// If a conversation thread falls within the ticket handling timespan, mark it
				if(convoThreadTimeStamp.isBetween(timeTicketBegan, timeTicketWasCompleted)){
					thread.isInReview = true;

					if(!firstConvoWithinTicket){
						firstConvoWithinTicket = thread;
					}else if(convoThreadTimeStamp.isBefore(moment(firstConvoWithinTicket.createdAt))){
						firstConvoWithinTicket = thread;
					}

					if(!lastConvoWithinTicket){
						lastConvoWithinTicket = thread;
					}else if(convoThreadTimeStamp.isAfter(moment(lastConvoWithinTicket.createdAt))){
						lastConvoWithinTicket = thread;
					}
				}
			});

			/* Apply styling classes to the first and last posts being reviewed so that the reviewer
			 can clearly see what part of the conversation is under review */
			if(firstConvoWithinTicket){
				firstConvoWithinTicket.reviewStartPoint = true;
			}

			if(lastConvoWithinTicket){
				lastConvoWithinTicket.reviewEndPoint = true;
			}
		}
	}
]);
