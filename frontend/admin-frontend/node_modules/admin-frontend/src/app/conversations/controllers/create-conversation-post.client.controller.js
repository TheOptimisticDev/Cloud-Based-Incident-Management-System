'use strict';

angular.module('conversations').controller('CreateConversationPostController', [
	'$scope',
	'$rootScope',
	'Authentication',
	'Conversations',
	'ConversationsPosts',
	'Accounts',
	'Integrations',
	'CannedResponses',
	'Employees',
	'Reservations',
	'Listing',
	'notify',
	'Handlebars',
	'$window',
	'dataFallback',
	'Contact',
	'User',
	'$uibModal',
	'ConversationsHelpers',
	function($scope, $rootScope, Authentication, Conversations, ConversationsPosts, Accounts, Integrations, CannedResponses, Employees, Reservations, Listing, notify, Handlebars, $window, dataFallback, Contact, User, $uibModal, ConversationsHelpers){
		// Conversation controller logic

		var self = this;

		//constants:

		// Qa Mode, if in Qa mode hide send button
		$scope.inQaMode = $scope.viewMode === 'QA';

		// possible options to send post at the future
		$scope.sendAt = {
			// options for sending time (locale time)
			options: [
				'Now',
				'07:00AM',
				'09:00AM',
				'12:00PM',
				'03:00PM',
				'08:00PM'
			],
			// default send at option
			chosenTime: 'Now',
			// default timezone for sending
			timezoneByName: 'Listing',
			// should hold the timezone string to save
			timezone: null
		};

		// hold all employees' basic info - for signature
		var employeesList;

		// Define guesty emails
		var guestyServiceEmail = 'Guesty Service <service@guesty.com>',
			guestySupportEmail = 'Guesty Support <support@guesty.com>',
			guestyPostBookingEmail = 'Guesty Post booking <cleanings@guesty.com>';

		// default emails to send post from
		$scope.defaultFromEmails = {
			User: guestyServiceEmail,
			Contact: guestyServiceEmail,
			Guest: 'The Host'
		};

		// possible emails to send the post from
		$scope.fromEmails = [
			guestyServiceEmail,
			guestySupportEmail,
			guestyPostBookingEmail
		];


		/**
		 * fill the email fields like: cc, bcc etc.
		 */
		function setEmailFields(){
			// delete those attribute to set them again only if necessary
			delete $scope.obj.from;
			delete $scope.obj.to;

			// if this post isn't an email - no need for any types of 'from' or 'to'.
			if($scope.obj.module !== 'email'){
				return;
			}

			// the default mail for the guest is the host's preferred email, which discovered by the platform at the moment of sending this message.
			if($scope.fromEmail !== $scope.defaultFromEmails.Guest){
				$scope.obj.from = $scope.fromEmail;
			}

			// Set 'to' field
			$scope.obj.to = [];

			// Add selected emails
			_.each($scope.obj.selectedEmailsTo, function(selectedEmailTo, email){
				if(selectedEmailTo) $scope.obj.to.push(email);
			});

			// Get 'to' field from host
			var to = $scope.obj.to ? $scope.obj.to : $scope.account.email ? $scope.account.email : $scope.account.emails;


			if($scope.obj.to_extra){
				if(!_.isArray(to)) to = [to];
				to = _.union(to, $scope.obj.to_extra.split(','));
			}

			// Add 'to' field to current message
			$scope.obj.to = to;

			// remove 'to' if didn't use and also couldn't (like unknown sender)
			if(!($scope.emailsTo || $scope.obj.to.length)){
				delete $scope.obj.to;
			}

			// Add 'cc' field
			$scope.obj.cc = $scope.obj.ccStr ? $scope.obj.ccStr.split(',') : [];

			// Add 'bcc' field
			$scope.obj.bcc = $scope.obj.bccStr ? $scope.obj.bccStr.split(',') : [];
		}

		/**
		 * create post object to save later
		 */
		function createPostObj(){
			$scope.obj = {
				employeeName: Authentication.getEmployee().username,
				message: '',
				subject: ($scope.conversation && $scope.conversation.thread[0]) ? $scope.conversation.thread[0].subject : '',
				module: getPreferredModule(),
				fromEmail: ($scope.defaultFromEmails[$scope.conversationWith] === $scope.fromEmails[0]) ? $scope.fromEmails[0] : $scope.defaultFromEmails[$scope.conversationWith],
				selectedEmailsTo: {}
			};

			_.each($scope.emailsTo || [], function(email){
				// clear emails of the account, that the account asked to -NOT- reply to them. (other email addresses in $scope.emailsTo can belong to guest/contact)
				if($scope.account && (($scope.account.emails && $scope.account.emails.indexOf(email) !== -1) || ($scope.account.email !== email))) return;
				$scope.obj.selectedEmailsTo[email] = true;
			});
			addGreeting();
			addSignatureToMessage();
		}

        /**
 		* adding 'Hi #guestName#' prefix to the message inside the composing area, to make it easier for the user.
         */
		function addGreeting(){
            var greeting = generateGreeting();
            $scope.obj.message = greeting;
        }

        function generateGreeting(){
            var suffix = ',\n';
            var contactName = ConversationsHelpers.getConversationContactName();
            if(contactName === "Guest"){
                contactName = self.reservation.guest.firstName;
            }
            if(contactName == "User"){
                //getting the account full name and parsing the first name from it when 'self.reservation' is exist.
                var accountFirstName = self.reservation && self.reservation.name ? self.reservation.account.name.split(' ')[0] : null
                contactName = accountFirstName;
            }
            if(contactName ==='conversation'){
                contactName = '';
            }
            var greetingTemplate = (!!contactName) ? 'Hi ' + contactName + suffix
                : 'Hi' + suffix;
            return getParsedTemplateTextForMessage(greetingTemplate);
        }

		/**
		 * building the message signature for the composing area, to make it easier for the user.
		 */
		function addSignatureToMessage(){
			$scope.obj.message += getParsedTemplateTextForMessage(getSignatureForMessage());
		}

		/**
		 * get the preferred module for this post
		 */
		function getPreferredModule(){
			// last module used at the current conversation (if exists)
			if($scope.conversation && $scope.conversation.thread.length){
				var postWithModule = _.find($scope.conversation.thread, function(post){
					return post.module;
				});
				if(postWithModule) return postWithModule.module;
			}
			// if it's a new conversation - will use the default module specified in user account
			if($scope.conversationWith === 'User' && $scope.user.preferredContactMethod){
				return $scope.user.preferredContactMethod;
			}
			// the default module
			return $scope.availableModules[0];
		}

		/**
		 * generate the signature for current conversation
		 * @returns {string}
		 */
		function getSignatureForMessage(){
			var respondAs = null,
				prefix = '\n';

			// for guests
			if(!$scope.newConversationParams && $scope.conversation.conversationWith === 'Guest'){
				/**
				 * define by who's name we should add a signature to the conversation
				 */

				//custom signature on the listing level
				if(_.get($scope, 'listing.receptionistsService.receptionDesk.customSignature')){
					respondAs = prefix + _.get($scope, 'listing.receptionistsService.receptionDesk.customSignature');
				}
				//custom signature on the account level
				else if(_.get($scope, 'account.receptionistsService.receptionDesk.customSignature')){
					respondAs = prefix + _.get($scope, 'listing.receptionistsService.receptionDesk.customSignature');
				}
				//default signature with white label on listing level
				else if(_.get($scope, 'listing.receptionistsService.receptionDesk.whiteLabel')){
					respondAs = prefix + _.get($scope, 'listing.receptionistsService.receptionDesk.customImpersonation', '{{host_first}}');
				}
				//default signature with white label on listing level
				else if(_.get($scope, 'account.receptionistsService.receptionDesk.whiteLabel')){
					respondAs = prefix + _.get($scope, 'account.receptionistsService.receptionDesk.customImpersonation', '{{host_first}}');
				}
				//default signature with no white label
				else{
					respondAs = prefix + 'Best,\n{{receptionist}}';
				}

			}else{
				respondAs = prefix + Authentication.getEmployee().presentableName.split(' ')[0];
			}

			return respondAs;
		}

		function removeSpecialCharactersFromText(content){
			return angular.element('<div/>').html(content).text();
		}

		/**
		 * get reservation data
		 * @param cb
		 */
		function getReservation(cb){
			if(!$scope.reservation || !$scope.reservation._id) return cb();
			self.reservation = Reservations.get({
				reservationId: $scope.reservation._id
			}, function(reservation){
				if(reservation.integration && reservation.integration._id){
					self.integration = Integrations.get({
						integrationId: reservation.integration._id,
						fields: 'firstName presentableName nickname'
					}, function(){
						cb();
					});
				}else cb();

			});
		}

		/**
		 * get reservation-box template as it will shown to a user
		 */
		function getReservationBox(cb){
			if(!self.reservation || !self.reservation._id) return cb();
			if($scope.conversationWith === 'Guest') return cb();
			if($scope.conversation && $scope.conversation.conversationWith === 'Guest') return cb();

			// should look like: {{[content]: {String}}}
			Reservations.reservationBox({
				reservationId: self.reservation._id
			}, function(reservationBox){
				if(reservationBox && reservationBox.content){
					$scope.reservationBox = reservationBox.content;
				}
				cb();
			});
		}

		/**
		 * get account data inc. integration
		 */
		function getAccount(cb){
			var accountId;
			// find the accountId
			if(self.reservation && self.reservation.accountId){
				accountId = self.reservation.accountId;
			}else if($scope.conversation && $scope.conversation.accountId){
				accountId = $scope.conversation.accountId;
			}else if($scope.newConversationParams){
				accountId = $scope.newConversationParams.accountId;
			}

			if(accountId){
				async.parallel({
					account: function(done){
						$scope.account = Accounts.get({
							accountId: accountId,
							fields: [
								'_id',
								'name',
								'timezone',
								'createdAt',
								'receptionistsService.receptionDesk.whiteLabel',
								'receptionistsService.receptionDesk.customImpersonation',
								'receptionistsService.receptionDesk.customSignature',
								'customFields'
							].join(' ')
						}, function(){
							done();
						}, function(){
							notify({
								message: 'could not find the account',
								classes: 'alert-danger'
							});
							done();
						});
					},
					users: function(done){
						User.query({
							accountId: accountId,
							fields: 'fullName email emails preferredContactMethod noteBeforeContacting'
						}, function(response){
							$scope.users = response.results;
							var userId = _.get($scope, 'conversation.userId') || _.get($scope, 'newConversationParams.userId');
							if(userId){
								$scope.user = _.find($scope.users, { '_id': userId });
							}
							done();
						}, function(){
							done();
						});
					},
					contacts: function(done){
						$scope.contacts = Contact.query({
							accountId: accountId,
							fields: 'fullName email emails'
						}, function(){
							done();
						}, function(){
							done();
						});
					}
				}, function(err, results){
					if(err) return cb();

					// Populate custom fields for SMS validation
					populateCustomFields($scope.account.customFields);

					setEmailsToList();
					if($scope.conversationWith === 'User'){
						$scope.sendAt.timezone = _.get($scope, 'user.timezone', _.get($scope, 'account.timezone'));
						$scope.sendAt.timezoneByName = 'User';
					}
					cb();
				});
			}else{    //unknown sender
				cb();
			}
		}

		function populateCustomFields(customFields){
			$scope.allowedVariables = [
				'{{user}}',
				'{{user_first}}',
				'{{integration_nickname}}',
				'{{host}}',
				'{{host_first}}',
				'{{checkin}}',
				'{{checkin_time}}',
				'{{checkout}}',
				'{{checkout_time}}',
				'{{planned_arrival_time}}',
				'{{planned_departure_time}}',
				'{{listing}}',
				'{{listing_nickname}}',
				'{{listing_address}}',
				'{{listing_address_city}}',
				'{{guest}}',
				'{{guest_first}}',
				'{{guest_email}}',
				'{{guest_phone}}',
				'{{guests_count}}',
				'{{nights_count}}',
				'{{receptionist}}',
				'{{confirmation_code}}',
				'{{fare_accommodation}}',
				'{{fare_cleaning}}',
				'{{host_payout}}',
				'{{notes_guest}}',
				'{{notes_cleaning}}',
				'{{notes_other}}'
			];

			var customVariables = (customFields || []).map(function(item){
				return '{{custom::' + item._id + '}}';
			});

			// Push to the standard-pre-defined list
			$scope.allowedVariables = $scope.allowedVariables.concat(customVariables);
		}

		/**
		 * get Listing data
		 */
		function getListing(cb){
			var listingId = _.get($scope, 'reservation.listingId') || _.get($scope, 'listingId');
			if(listingId){
				$scope.listing = Listing.get({
					listingId: listingId,
					fields: ['_id',
						'timezone',
						'title',
						'nickname',
						'address',
						'receptionistsService.receptionDesk.whiteLabel',
						'receptionistsService.receptionDesk.customImpersonation',
						'receptionistsService.receptionDesk.customSignature'
					].join(' ')
				}, function(){
					if($scope.conversationWith !== 'User'){
						$scope.sendAt.timezone = $scope.listing.timezone;
						$scope.sendAt.timezoneByName = 'Listing';
					}
					cb();
				});
			}else cb();
		}

		/**
		 * merge list of email for the 'to' column, with the account emails and the sender(guest \ contact)
		 */
		function setEmailsToList(){
			var conversation = $scope.isNewConversation ? $scope.newConversationParams : $scope.conversation;
			if($scope.conversationWith === 'Guest' && self.reservation && self.reservation.guest && !self.reservation.guest.email){
				return setReplyToSender();
			}else if($scope.conversationWith === 'Contact' && (conversation.contact || conversation.contactId)){
				$scope.contact = _.find($scope.contacts.results, { '_id': conversation.contact ? conversation.contact._id : conversation.contactId });
				if(!$scope.contact || !$scope.contact.email){
					return setReplyToSender();
				}
			}else if($scope.conversationWith === 'User' && conversation.userId && !$scope.user){
				$scope.user = _.find($scope.users, { '_id': conversation.userId });
				if(!$scope.user || !$scope.user.email){
					return setReplyToSender();
				}
			}

			if($scope.conversationWith === 'Guest'){
				$scope.emailsTo = [_.get(self.reservation, 'guest.email')];
			}else{
				$scope.emailsTo = _.uniq([].concat(
					$scope.contact ? $scope.contact.email : [],
					$scope.user ? $scope.user.emails : []));
			}
		}

		function setReplyToSender(){
			delete $scope.emailsTo;
		}

		/**
		 * get system and listing's canned responses
		 */

		function getCannedResponses(cb){
			getIttt();
            var reservationStatus = self.reservation && self.reservation.status ? self.reservation.status : $scope.reservation ? $scope.reservation.status : $scope.ticket && $scope.ticket.reservation ? $scope.ticket.reservation.status : null;
            var conversationWith =   ($scope.conversation && $scope.conversation.conversationWith) ?  $scope.conversation.conversationWith : ($scope.conversationWith || $scope.newConversationParams.conversationWith);
			CannedResponses.getRelevant({
				accountId: self.reservation && self.reservation.accountId ? self.reservation.accountId : $scope.account ? $scope.account._id : $scope.ticket ? $scope.ticket.accountId : null,
				listingId: self.reservation && self.reservation.listingId ? self.reservation.listingId : $scope.reservation ? $scope.reservation.listingId : $scope.ticket ? $scope.ticket.listingId : null,
				conversationWith: conversationWith,
				hasReservation: reservationStatus === 'confirmed',
			}, function(responses){
				var canned = [];
				//group in folders
				_.each(responses, function(response){
					//no folder, just add
					if(!response.folder) return canned.push(response);

					//find existing item with same folder
					var group = _.find(canned, { 'folder': response.folder });
					//add to that
					if(group){
						group.items.push(response);
					}
					//or create new folder
					else{
						canned.push({
							folder: response.folder,
							items: [response]
						});
					}
				});
				$scope.cannedResponses = canned.sort(sortCannedResponses);

				if(cb) cb();
			});
		}

		function getIttt(cb){
			async.parallel({
				account: function(done){
					Accounts.get({
						accountId: self.reservation && self.reservation.accountId ? self.reservation.accountId : $scope.account ? $scope.account._id : $scope.ticket ? $scope.ticket.accountId : null,
						fields: 'receptionistsService.receptionDesk.ittt'
					}, function(response){
						done(null, response);
					}, done);
				},
				listing: function(done){
					Listing.get({
						listingId: self.reservation && self.reservation.listingId ? self.reservation.listingId : $scope.reservation ? $scope.reservation.listingId : $scope.ticket ? $scope.ticket.listingId : null,
						fields: 'receptionistsService.receptionDesk.ittt'
					}, function(response){
						done(null, response);
					}, done);
				}
			}, function(err, results){
				if(err) return;

				//push the listing
				var ittt = _.get(results.listing, 'receptionistsService.receptionDesk.ittt', []);

				//add the account that were not overridden
				_.each(_.get(results.account, 'receptionistsService.receptionDesk.ittt', []), function(item){
					if(!_.find(ittt, { ifThis: item.ifThis })){
						ittt.push(item);
					}
				});

				//then sort
				ittt = _.sortBy(ittt, 'ifThis');

				//set to view
				$scope.ittt = ittt;
			});
		}

		$scope.openIttt = function(item){
			$uibModal.open({
				size: 'md',
				templateUrl: 'app/accounts/views/account/receptionists/ittt.readonly.modal.client.view.html',
				controller: 'CustomerReceptionistsItttModalController as itttCtrl',
				resolve: {
					ittt: function(){
						return item;
					}
				}
			});
		};

		/**
		 * return available modules for this post
		 * @returns {$scope.newConversationParams.availableReplyModules|*}
		 */
		function getAvailableModules(){
			return ($scope.conversation || $scope.newConversationParams).availableReplyModules;
		}

		/**
		 * get textual string from a DOM element.
		 * @param el
		 * @returns {String}
		 */
		function getRegularTextFromHTML(el){
			el = angular.element(el);
			var lines = el.children('p, h1, h2, h3, h4, h5, div');
			if(!lines.length) return angular.element('<div />').html(el.html().replace(/<br>/g, '\n').replace(/<br\/>/g, '\n')).text();
			return _.map(lines, function(a){
				return getRegularTextFromHTML(a);
			}).join('\n');
		}

		/**
		 * return string with html tags instead of new lines
		 * @param text
		 * @returns {string}
		 */
		function getHTMLFromRegularText(text){
			return text.replace(/\n/g, '<br />');
		}

		/**
		 * parse content with the conversation data-object
		 * @param content
		 * @returns {*}
		 */
		function getParsedTemplateTextForMessage(content){
            var options;
			if($scope.obj.module === 'email'){
				options = {};
				content = getHTMLFromRegularText(content);
			}
			else{
                options = { noEscape: true };
			}

			//var options = $scope.obj.module === 'email' ? {} : { noEscape: true };
				return Handlebars.compile(content, options)(getDataObjectForTemplateParse());
		}

		function getDataObjectForTemplateParse(){
			if(!$scope.account) return {};

			var integration = self.integration || {};

			var hostCompany = $scope.account ? $scope.account.name : '';
			var hostName = integration && integration.presentableName ?
				integration.presentableName : $scope.account.name ?
					$scope.account.name : '';
			var hostFirstName = integration && integration.firstName ? integration.firstName :
				integration.presentableName ? integration.presentableName.split(' ')[0] :
					$scope.account.firstName ? $scope.account.firstName : '';

			var conversation = $scope.conversation || {};
			var reservation = self.reservation || {};
			if(!reservation.money) reservation.money = {};
			var listing = $scope.listing || reservation.listing || {};
			var guest = reservation.guest || {};

			var obj = {
				_id: $scope.account ? $scope.account._id : '{{NO-CUSTOMER-ID}}',
				user: $scope.account.name || '',
				user_first: $scope.account.firstName || '',
				host: hostCompany || hostName || '',
				host_first: hostFirstName || hostCompany || '',
				guest: guest.fullName || '{{NO-GUEST-NAME}}',
				guest_first: guest.firstName ? guest.firstName : '{{NO-GUEST-NAME}}',
				guest_email: guest.email || '{{NO-GUEST-EMAIL}}',
				guest_phone: guest.phone || '{{NO-GUEST-PHONE}}',
				receptionist: conversation.firstReceptionist || Authentication.getEmployee().presentableName,
				fare_accommodation: reservation.money.fareAccommodation || '{{NO-FARE-ACCOMMODATION}}',
				fare_cleaning: reservation.money.fareCleaning || '{{NO-FARE-CLEANING}}',
				host_service_fee: reservation.money.hostServiceFee || '{{NO-HOST-SERVICE-F}}EE',
				host_taxes: reservation.money.hostTaxes || '{{NO-HOST-TAXES}}',
				host_payout: reservation.money.hostPayout || '{{NO-HOST-PAYOUT}}',
				our_commission: reservation.money.ourCommission || '{{NO-OUR-COMMISSION}}',
				our_fee: reservation.money.ourFee || '{{NO-OUR-FEE}}',
				confirmation_code: reservation.confirmationCode || '{{NO-CONFIRMATION-CODE}}',
				nights_count: reservation.nightsCount || '{{NO-NIGHTS-COUNT}}',
				guests_count: reservation.guestsCount || '{{NO-GUESTS-COUNT}}',
				signature: getSignatureForMessage(),
				integration_nickname: integration ? integration.nickname : ''
				//,external_conversation_link: (reservation.platform === 'airbnb') ? 'https://www.airbnb.com/z/q/' + conversation.platformId : '{{EXTERNAL-LINK-UNKNOWN}}'
			};

			// get listing automation variables
			if($scope.listing){
				_.extend(obj, {
					listing: listing.title || '{{NO-LISTING-TITLE}}',
					listing_label: listing.nickname || '{{NO-LISTING-Nickname}}',
					listing_address: listing.address && listing.address.full ? listing.address.full : '{{NO-LISTING-ADDRESS}}',
					listing_address_city: listing.address && listing.address.city ? listing.address.city : '{{NO-LISTING-CITY}}',

					//todo: these are not related to $scope.listing
					checkin: reservation.checkIn ? moment.tz(reservation.checkIn, listing.timezone).format('MMM. DD') : '{{NO-CHECK-IN}}',
					checkin_time: '{{NO-CHECK-IN-TIME}}', //reservation.withTimezone.checkInTime,
					checkout: reservation.checkOut ? moment.tz(reservation.checkOut, listing.timezone).format('MMM. DD') : '{{NO-CHECK-OUT}}',
					checkout_time: '{{NO-CHECK-OUT-TIME}}', //reservation.withTimezone.checkOutTime,
					planned_arrival_time: '{{NO-PLANNED-ARRIVAL-TIME}}',
					planned_departure_time: '{{NO-PLANNED-DEPARTURE-TIME}}'
				});
			}
			return obj;
		}

		/**
		 * change anchor tags that link to the admin-panel
		 */
		function removeAdminAnchorsFromMessage(){
			if($scope.obj.module === 'email'){
				$scope.obj.message = angular.element('<div />').html($scope.obj.message);
				$scope.obj.message.find('a[href*="' + $window.location.host + '"]').attr('href', '');
				$scope.obj.message = $scope.obj.message.html();
			}
		}

		/**
		 * snooze conversation
		 * @param conversationId
		 * @param shouldBePushedAt
		 */
		function snoozeConversation(conversationId, shouldBePushedAt){
			Conversations.snooze({
				conversationId: conversationId
			}, {
				shouldBePushedAt: shouldBePushedAt
			});
		}

		function getAllNeededData(){
			// list of all employees is needed first, to make the post signature, canned responses, etc..
			employeesList = Employees.query({}, function(){
				async.parallel([
					getAccount,
					getListing,
                    getReservationBox,
                    getCannedResponses
				], function(){
					createPostObj();
				});
			});
			$scope.conversationWith = ($scope.conversation || $scope.newConversationParams).conversationWith;
		}

		function enableButtons(){
			$scope.disableSaveButton = false;
		}

		function callSaveMethod(){
			removeAdminAnchorsFromMessage();
			setEmailFields();

			var shouldBePushedAt = $scope.obj.shouldBePushedAt;

			function snoozeIfAsked(conversationOrPost){
				// check if need to snooze conversation
				if(shouldBePushedAt) snoozeConversation($scope.isNewConversation ? conversationOrPost._id : $scope.conversation._id);
			}

			if(self.reservation && self.reservation._id){
				$scope.obj.reservationId = self.reservation._id;
			}

			if($scope.account){
				$scope.obj.accountId = $scope.account._id;
			}

			if($scope.user){
				$scope.obj.userId = $scope.user._id;
			}

			// create new conversation from parent scope
			if($scope.isNewConversation){
				$scope.createConversation($scope.obj, function(conversation){
					notify({
						message: 'Added to queue',
						classes: 'alert-success'
					});
					snoozeIfAsked(conversation);
					updateTicketActivity();
					reportToAnalytics();
					$scope.findOne(true);
				}).finally(enableButtons);
			}else{
				// create new conversation post
				var post = new ConversationsPosts($scope.obj);
				post.threadLength = _.filter($scope.conversation.thread, function(post){
					return !post.isLog;
				}).length;
				post.conversationLastUpdatedAt = $scope.conversation.lastUpdatedAt;
				post.$save({
					conversationId: $scope.conversation._id
				}, function(){
					notify({
						message: 'Added to queue',
						classes: 'alert-success'
					});
					snoozeIfAsked();
					updateTicketActivity();
					reportToAnalytics();
					createPostObj();
					$scope.findOne();
				}, function(){
					notify({
						message: 'Post could not be send',
						classes: 'alert-danger'
					});
				}).finally(enableButtons);
			}
		}

		function updateTicketActivity(){
			if(!$scope.ticket) return;
			$scope.ticket.repliedToConversation = true;
		}

		function reportToAnalytics(){
			/*todo: Analytics.track('Conversation Post - Sent message', _.extend({
			 accountName: $scope.account ? $scope.account.name : null,
			 accountId: $scope.account ? $scope.account._id : null,
			 conversationWith: $scope.conversation ? $scope.conversation.conversationWith : $scope.conversationWith,
			 platform: $scope.conversation ? $scope.conversation.platform : null
			 }, $scope.obj));*/
		}

		// Public

		$scope.observeForm = function(formController){
			$scope.smsForm = formController;
		};
		$scope.authentication = Authentication;

		$scope.setSendAtTime = function setSendAtTime(time){
			if(!$scope.sendAt) $scope.sendAt = {};

			$scope.sendAt.chosenTime = time;
			if($scope.sendAt.chosenTime === 'Now'){
				delete $scope.obj.sendAt;
			}else{
				//is today? or tomorrow?
				var timeNow = moment.tz($scope.sendAt.timezone);
				var timeSet = moment.tz(time, 'hh:mmA', $scope.sendAt.timezone);
				if(timeSet < timeNow){
					timeSet = timeSet.add(1, 'day');
				}
				$scope.obj.sendAt = timeSet.toDate();
				$scope.sendAt.howFar = Math.floor(moment.duration(timeSet - timeNow).asHours());
			}
		};

		/**
		 * initialize the controller
		 */
		$scope.init = function(){
			$scope.isNewConversation = !!$scope.newConversationParams;
			if(!$scope.conversation && !$scope.isNewConversation){
				notify({
					message: 'could not detect a conversation or new-conversation',
					classes: 'alert-danger'
				});
				return;
			}
			$scope.availableModules = getAvailableModules();
			if(!$scope.availableModules || $scope.availableModules.length === 0){
				notify({
					message: 'could not detect a available reply methods to compose new post',
					classes: 'alert-danger'
				});
				return;
			}

			// for new conversation, if notification exists - can use notification like a reservation
			if($scope.isNewConversation && $scope.notification){
				self.reservation = $scope.notification;
				getAllNeededData();
			}else{
				getReservation(getAllNeededData);
			}
		};

    $rootScope.$on('ticketConversationSelected', function() {
      $scope.init();
    });

    function validateMessage(){
			if(!$scope.obj.message) return false;
			if($scope.obj.message.match(/\#\#\#\#.+/)) return false;
			if($scope.obj.message.match(/\{\{.+\}\}/)) return false;
			if($scope.smsForm && $scope.obj.module === 'sms'){
				if($scope.smsForm.$invalid) return false;
			}
			return true;
		}

		/**
		 * save the conversation-post
		 */
		$scope.save = function(){
			//validate message
			if(!validateMessage()){
				notify({
					message: 'Message contains warnings or placeholders. Not sending!',
					classes: 'alert-danger'
				});
				return;
			}else if($scope.obj.module === 'email' && !$scope.obj.subject){
				notify({
					message: 'Email with no subject line',
					classes: 'alert-danger'
				});
				return;
			}

			//save
			$scope.disableSaveButton = true;
			callSaveMethod();
		};

		/**
		 * choose a reply module from one of the available reply modules
		 * @param module {String} - the module key
		 */
		$scope.changeMessageModule = function(module){
			var prevModule = $scope.obj.module;
			$scope.obj.module = module;

			// If text box is empty obj.message maybe undefined, so initialize
			$scope.verifyMessageBoxIsDefined();

			if(['email', 'rentalsUnited'].indexOf(prevModule) !== -1){
				$scope.obj.message = getRegularTextFromHTML('<div>' + $scope.obj.message + '</div>');
			}else if(['email', 'rentalsUnited'].indexOf(module) !== -1){
				$scope.obj.message = getHTMLFromRegularText($scope.obj.message);
			}
		};

		/**
		 * set the canned response template to the content
		 * @param cannedResponse
		 */
		$scope.setCannedResponse = function(cannedResponse){

			$scope.verifyMessageBoxIsDefined();

			//only add once- no duplications
			if($scope.isTextIncludedInMessage(cannedResponse.answer)) return;

			//
			var content = cannedResponse.answer + '\n',
				signature = getParsedTemplateTextForMessage(getSignatureForMessage());

			// if the message is a mail, the content should be as HTML
			if($scope.obj.module === 'email'){
				content = getHTMLFromRegularText(content);
			}else{
				content = removeSpecialCharactersFromText(content);
			}
			//remove greeting in order to prevent double greeting caused by canned response
            $scope.obj.message = removeGreeting($scope.obj.message, generateGreeting());
			// remove the signature from current message temporarily
			$scope.obj.message = removeSignature($scope.obj.message, signature.trim());

			// add the canned-response to the message content, after the current content, prepend the intro and lastly append the signature
			$scope.obj.message = generateGreeting() + $scope.obj.message;
			$scope.obj.message += getParsedTemplateTextForMessage(content) + signature;
		};

		/**
		 * Remove signature from string, if signature string appears in the middle of the message. For example
		 * if a host name or receptionist name is the same as the signature, cut out the last part of the string instead of doing a replace
		 * @param message: STRING, signatureString: STRING
		 * @returns The message without the signature
		 */
		function removeSignature(message, signatureString){
			// Make the signature exists before removing it
			if(!!message && !!signatureString && message.lastIndexOf(signatureString) > -1){ // If message is not empty string
				return message.substring(0, message.lastIndexOf(signatureString));
			}

			return message;
		}

        /**
		 * used for removing the greeting from msg when adding canned responses
         * @param message
         * @param greeting
         * @returns {*}
         */
        function removeGreeting(message, greeting){
            // Make the signature exists before removing it
            if(!!message && !!greeting && message.indexOf(greeting) > -1){ // If message is not empty string
                return message.replace(greeting, '');
            }

            return message;
        }

		/**
		 * check if the given string is included in the message
		 * @param str
		 * @returns {boolean}
		 */
		$scope.isTextIncludedInMessage = function(str){
			if($scope.obj.module === 'email'){
				str = getHTMLFromRegularText(str);
			}
			return ($scope.obj.message && $scope.obj.message.indexOf(str) !== -1);
		};

		$scope.getColorByType = function(cannedResponse){
			var type = '';
			if(_.isArray(cannedResponse)){
				_.each(cannedResponse, function(item){
					var newType = (item.listingsIds && item.listingsIds.length) ? 'listing' : item.accountId ? 'account' : 'global';
					if(!type) type = newType;
					else if(type !== newType){
						type = 'mixed';
						return false;
					}
				});
				return type === 'listing' ? 'btn-success' : type === 'account' ? 'btn-warning' : type === 'global' ? 'btn-primary' : type === 'mixed' ? 'btn-primary mixed' : 'btn-default';
			}

			if(cannedResponse.accountId && cannedResponse.listingsIds && cannedResponse.listingsIds.length){
				return 'btn-success';
			}else if(cannedResponse.accountId){
				return 'btn-warning';
			}else{
				return 'btn-primary';
			}
		};

		$scope.verifyMessageBoxIsDefined = function(){
			if(typeof $scope.obj.message === 'undefined'){
				$scope.obj.message = '';
			}
		};

		function sortCannedResponses(firstCR, secondCR){
			if((_.isArray(firstCR.items))){
				firstCR = firstCR.items[0];
			}

			if((_.isArray(secondCR.items))){
				secondCR = secondCR.items[0];
			}

			if(responseIsAListing(firstCR)){
				if(responseIsAListing(secondCR)) return 0;
				return -1;
			}else if(responseIsAnAccount(firstCR)){
				if(responseIsAListing(secondCR)) return 1;
				if(responseIsAnAccount(secondCR)) return 0;
				return -1;
			}else{
				if(responseIsAListing(secondCR)) return 1;
				if(responseIsAnAccount(secondCR)) return 1;
				return 0;
			}
		}

		function responseIsAListing(cannedResponse){
			return cannedResponse.accountId && cannedResponse.listingsIds && cannedResponse.listingsIds.length;
		}

		function responseIsAnAccount(cannedResponse){
			return cannedResponse.accountId && (!cannedResponse.listingsIds || (cannedResponse.listingsIds && cannedResponse.listingsIds.length == 0));
		}
	}
]);
