'use strict';

// Canned Responses controller
angular.module('templates').controller('CannedResponsesController', [
    '$scope',
    '$stateParams',
    'CannedResponses',
    'CommonService',
    'gNotify',
    'dataFallback',
    'CannedResponsesModals',
    '$rootScope',
	function($scope, $stateParams, CannedResponses, CommonService, gNotify, dataFallback, CannedResponsesModals, $rootScope) {

        function queryParams(){
            var obj = {};

            if ($scope.listing) {
                obj.listingId = $scope.listing._id;
                obj.accountId = $scope.listing.accountId;
            } else if($scope.account) {
                obj.accountId = $scope.account._id;
            } else if ($scope.queryParams) {
                obj = $scope.queryParams;
            }

            return obj;
        }

		// Find a list of Canned Responses
		$scope.find = function() {
            var params = queryParams();
            $scope.importCannedResponses = false;
            if(!params.accountId && !params.listingId) $scope.isGlobalCannedResponses = true;
            CannedResponses.queryGroupedByWith(params, function(allTemplates){
                $scope.cannedResponses = _.mapValues(allTemplates, function(templates){
                    //group by status of reservation
                    var results = _.groupBy(templates, function(template){
                        return template.applyWhenNoBooking && template.applyWhenHasBooking ? 'always' : template.applyWhenHasBooking ? 'with confirmed reservation' : template.applyWhenNoBooking ? 'without confirmed reservation' : 'Error';
                    });

                    //group by folders (in each group)
                    results = _.mapValues(results, function(templatesGroupedByStatus){
                        var canned = [];
                        _.each(templatesGroupedByStatus, function(template){
                            if (!template.folder) return canned.push(template);

                            var group = _.find(canned, function(item){
                                return item.folder === template.folder;
                            });
                            if (group){
                                group.items.push(template);
                            } else {
                                canned.push({
                                    folder: template.folder,
                                    items : [template],
                                    conversationType: template.conversationType
                                });
                            }
                        });
                        return canned;
                    });
                    return results;
                });
            });
		};

        $scope.openCannedResponseModal = function(cannedResponseId) {
            CannedResponsesModals.open(cannedResponseId || null, queryParams()).then(function() {
                $scope.find();
                $rootScope.$broadcast('cannedResponse:updated');
            });
        };

        $scope.getColorByType = function(item) {
            if (!item) return 'btn-default';
            return {
                'btn-primary': item.conversationType === 'guest',
                'btn-success': item.conversationType === 'user',
                'btn-warning': item.conversationType === 'contact',
                'btn-default': !item.conversation,
                'multiple-listings': item.listingsIds && item.listingsIds.length > 1
            };
        };

        $scope.toggleImportCannedResponses = function() {
            $scope.importCannedResponses = !$scope.importCannedResponses;
            if($scope.importCannedResponses) {
                $scope.importParams = queryParams();
            } else {
                $scope.find();
            }
        };
	}
]);
